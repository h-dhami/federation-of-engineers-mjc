#pragma config(Sensor, dgtl1,  slideIsDown,    sensorDigitalIn)
#pragma config(Sensor, dgtl2,  slideIsUp,      sensorDigitalIn)
#pragma config(Motor,  port2,           motorFR,       tmotorServoContinuousRotation, openLoop, driveRight)
#pragma config(Motor,  port3,           motorFL,       tmotorServoContinuousRotation, openLoop, reversed, driveLeft)
#pragma config(Motor,  port4,           motorBR,       tmotorServoContinuousRotation, openLoop, driveRight)
#pragma config(Motor,  port5,           motorBL,       tmotorServoContinuousRotation, openLoop, reversed, driveLeft)
#pragma config(Motor,  port6,           motorCatch,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           motorSlide,    tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* 
Copyright 2017 Herman Dhami

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/* BOLT CATCHER PROGRAM
 * Program 
 * Inputs: User joystick commands, left-analog sticks's y-axis 
 * controlling the left-hand side of the robot, right-analog stick's y-
 * axis controlling the right-hand side of the robot. Top-right bumper 
 * engages the bolt collector.
 */

task main() {
	// Declares variables that read user inputs and control motor outputs
	int joy_l; // for left wheels
	int joy_r; // for right wheels
	int threshold = 10; // threshold value, so user input must a minimum
						// value for the robot to actually move.
	int modifier = 2; // set the joystick to move the robot at half speed
					  // 3 -> one-third speed, 4 -> one-quarter speed, ...
	int catch_modifier = 2; // sets the catching mechanism to half speed;
	while (1 == 1) {
		// sets the variables declared above to left and right analog stick
		joy_l = vexRT[ch3];
		joy_r = vexRT[ch2];
		
		// if neither analog stick exceeds the threshold, do not move.
		if (abs(joy_l) < threshold && abs(joy_r) < threshold) {
			motor[motorBL] = motor[motorFL] = motor[motorBR] 
			    = motor[motorFR] = 0;
		}
		// if only the right-analog stick exceeds the threshold, move the 
		// right side only
		else if (abs(joy_l) < threshold) {
			motor[motorBL] = motor[motorFL] = 0;
			motor[motorBR] = motor[motorFR] = joy_r / modifier;
		}
		// if only the left-analog stick exceeds the threshold, move the 
		// left side only
		else if (abs(joy_l) < threshold) {
			motor[motorBL] = motor[motorFL] = joy_l / modifier;
			motor[motorBR] = motor[motorFR] = 0;
		}
		// if both analog stick's exceed the threshold, move both;
		else {
			motor[motorBL] = motor[motorFL] = joy_l / modifier;
			motor[motorBR] = motor[motorFR] = joy_r / modifier;
		}
		
		// Engages the motor-catching mechanism
		// Top-right bumper causes catcher to PULL in material completely.
		if (vexRT[Btn6U] == 1) {
			motor[motorCatch] = 127 / catch_modifier;
		}
		// Bottom-right bumper causes catcher to PUSH out material
		// completely.
		else if (vexRT[Btn6D] == 1) {
			motor[motorCatch] = -128 / catch_modifier;
		}
		// No bumper activated causes catcher to disengage completely.
		else {
			motor[motorCatch] = 0;
		}
		
		// Engages the slide motor
		// Increases the height of the slide motor
		if (vexRT[Btn5U] == 1 && SensorValue(slideIsUp) != 0) {
			motor[motorSlide] = 127 / 2 / catch_modifier;
		}
		// Decreases the heigh of the slide motor
		else if (vexRT[Btn5D] == 1 && SensorValue(slideIsDown) != 0) {
			motor[motorSlide] = -128 / 2 / catch_modifier;
		}
		// Keeps the motor from sliding
		else {
			motor[motorSlide] = 0;
		}
		
		// Increase or decrease movement modifiers
		// For faster vehicular movement
		if (vexRT[Btn7U] == 1 && modifier != 1) {
			modifier--;
			wait1Msec(500);
		}
		// For slower vehicular movement
		else if (vexRT[Btn7D] == 1 && modifier != 6) {
			modifier++;
			wait1Msec(500);
		}
		
		// Increase or decrease catch modifier
		// For faster catch movement
		if (vexRT[Btn8U] == 1 && catch_modifier != 1) {
			catch_modifier--;
			wait1Msec(500);
		}
		// For slower catch movement
		else if (vexRT[Btn8D] == 1 && catch_modifier != 6) {
			catch_modifier++;
			wait1Msec(500);
		}
	}
}
